"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils = require('ethereumjs-utils');
const parser = require('truffle-code-utils');
const FUNCTION_SELECTOR_OPCODES = JSON.stringify(['DUP1', 'PUSH4', 'EQ', 'PUSH2', 'JUMPI']);
const FUNCTION_SELECTOR_OPCODES2 = JSON.stringify(['AND', 'PUSH4', 'DUP2', 'EQ', 'PUSH2']);
const FUNCTION_SELECTOR_OPCODES23 = JSON.stringify(['AND', 'PUSH4', 'DUP2', 'EQ', 'PUSH3']);
const FUNCTION_SELECTOR_OPCODES3 = JSON.stringify(['DUP1', 'PUSH4', 'EQ', 'PUSH3', 'JUMPI']);
const FUNCTION_SELECTOR_OPCODES4 = JSON.stringify(['DUP1', 'PUSH4', 'EQ', 'PUSH4', 'JUMPI']);
const FUNCTION_SELECTOR_OPCODES5 = JSON.stringify(['DUP2', 'PUSH4', 'EQ', 'PUSH2', 'JUMPI']);
/**
 * The AbiFunctions class managing about SmartContract functions information.
 */
class AbiFunctions {
    /**
     * constructor
     * @param {string} opcodes is bytecodes of SmartContract
     */
    constructor(opcodes = '') {
        this.opcodes = opcodes;
        this.selectors = [];
        if (opcodes && opcodes.length > 0) {
            this.selectors = this._parseCode(opcodes);
        }
    }
    /**
     * get function ids from opcode.
     * @return {string[]}
     */
    getFunctionIds() {
        return this.selectors.map((s) => s[1].pushData);
    }
    getFunctionPcs(){
        return this.selectors.map((s) => s[1].pc)
    }
    /**
     * If functionId is exists, then return program counter of function start point.
     * @param {string} functionId
     * @return {number} The program counter of function start position
     */
    findProgramCounter(functionId) {
        // PUSH2 is function position
        if (this.selectors.length === 0) {
            return null;
        }
        else {
            const pc = this.selectors.map((s) => {
                const info = {
                    id: s.filter((e) => e.name === 'PUSH4').map((e) => e.pushData)[0],
                    pc: s.filter((e) => e.name === 'PUSH2').map((e) => e.pushData)[0]
                };
                return info;
            }).filter((s) => s.id === functionId)
                .map((s) => utils.toBuffer(s.pc).readInt16BE(0))[0];
            return pc ? pc : null;
        }
    }
    /**
     * Extract function ids from header part
     * @param {string} opcodes
     * @return {Array<any>}
     * @private
     */
    _parseCode(opcodes) {
        const inspections = parser.parseCode(opcodes);
        const push4Indexes = inspections.map((e, i) => e.name === 'PUSH4' ? i : -1).filter((i) => i > -1);
        const expections = push4Indexes.map((i) => inspections.slice(i - 1, i + 4));
        // inspections.forEach(((e: any) => console.log(e)))
        return expections.filter((e) => this._isFunctionSelector(e));
    }
    _isFunctionSelector(opcodes) {
        const names = opcodes.map((o) => o.name);
        return (JSON.stringify(names) === FUNCTION_SELECTOR_OPCODES || JSON.stringify(names) === FUNCTION_SELECTOR_OPCODES2 || JSON.stringify(names) === FUNCTION_SELECTOR_OPCODES3 || JSON.stringify(names) === FUNCTION_SELECTOR_OPCODES23 || JSON.stringify(names) === FUNCTION_SELECTOR_OPCODES4 || JSON.stringify(names) == FUNCTION_SELECTOR_OPCODES5);
    }
}
exports.default = AbiFunctions;
//# sourceMappingURL=index.js.map